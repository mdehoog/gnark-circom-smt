package emulated

import (
	"math/big"

	"github.com/consensys/gnark/std/math/emulated"

	"github.com/mdehoog/gnark-circom-smt/circuits/poseidon"
)

func Sigma[T emulated.FieldParams](field *emulated.Field[T], in *emulated.Element[T]) *emulated.Element[T] {
	in2 := field.Mul(in, in)
	in4 := field.Mul(in2, in2)
	return field.Mul(in4, in)
}

func Ark[T emulated.FieldParams](field *emulated.Field[T], in []*emulated.Element[T], c []*emulated.Element[T], r int) []*emulated.Element[T] {
	out := make([]*emulated.Element[T], len(in))
	for i, v := range in {
		out[i] = field.Add(v, c[i+r])
	}
	return out
}

func Mix[T emulated.FieldParams](field *emulated.Field[T], in []*emulated.Element[T], m [][]*emulated.Element[T]) []*emulated.Element[T] {
	t := len(in)
	out := make([]*emulated.Element[T], t)
	for i := 0; i < t; i++ {
		lc := field.NewElement(0)
		for j := 0; j < t; j++ {
			lc = field.Add(lc, field.Mul(m[j][i], in[j]))
		}
		out[i] = lc
	}
	return out
}

func MixLast[T emulated.FieldParams](field *emulated.Field[T], in []*emulated.Element[T], m [][]*emulated.Element[T], s int) *emulated.Element[T] {
	t := len(in)
	out := field.NewElement(0)
	for j := 0; j < t; j++ {
		out = field.Add(out, field.Mul(m[j][s], in[j]))
	}
	return out
}

func ArrayToElement[T emulated.FieldParams](a []*big.Int) []*emulated.Element[T] {
	out := make([]*emulated.Element[T], len(a))
	for i, v := range a {
		o := emulated.ValueOf[T](v)
		out[i] = &o
	}
	return out
}

func Array2ToElement[T emulated.FieldParams](a [][]*big.Int) [][]*emulated.Element[T] {
	out := make([][]*emulated.Element[T], len(a))
	for i, v := range a {
		out[i] = ArrayToElement[T](v)
	}
	return out
}

func HashEx[T emulated.FieldParams](field *emulated.Field[T], inputs []*emulated.Element[T], initialState *emulated.Element[T], nOuts int) []*emulated.Element[T] {
	nInputs := len(inputs)
	out := make([]*emulated.Element[T], nOuts)

	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
	nRoundsPC := [16]int{56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68}
	t := nInputs + 1
	nRoundsF := 8
	nRoundsP := nRoundsPC[t-2]
	c := ArrayToElement[T](poseidon.POSEIDON_C(t))
	s := ArrayToElement[T](poseidon.POSEIDON_S(t))
	m := Array2ToElement[T](poseidon.POSEIDON_M(t))
	p := Array2ToElement[T](poseidon.POSEIDON_P(t))

	state := make([]*emulated.Element[T], t)
	for j := 0; j < t; j++ {
		if j == 0 {
			state[0] = initialState
		} else {
			state[j] = inputs[j-1]
		}
	}
	state = Ark(field, state, c, 0)

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = Sigma(field, state[j])
		}
		state = Ark(field, state, c, (r+1)*t)
		state = Mix(field, state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = Sigma(field, state[j])
	}
	state = Ark(field, state, c, nRoundsF/2*t)
	state = Mix(field, state, p)

	for r := 0; r < nRoundsP; r++ {

		state[0] = Sigma(field, state[0])

		state[0] = field.Add(state[0], c[(nRoundsF/2+1)*t+r])
		newState0 := field.NewElement(0)
		for j := 0; j < len(state); j++ {
			mul := field.Mul(s[(t*2-1)*r+j], state[j])
			newState0 = field.Add(newState0, mul)
		}

		for k := 1; k < t; k++ {
			state[k] = field.Add(state[k], field.Mul(state[0], s[(t*2-1)*r+t+k-1]))
		}
		state[0] = newState0
	}

	for r := 0; r < nRoundsF/2-1; r++ {
		for j := 0; j < t; j++ {
			state[j] = Sigma(field, state[j])
		}
		state = Ark(field, state, c, (nRoundsF/2+1)*t+nRoundsP+r*t)
		state = Mix(field, state, m)
	}

	for j := 0; j < t; j++ {
		state[j] = Sigma(field, state[j])
	}

	for i := 0; i < nOuts; i++ {
		out[i] = MixLast(field, state, m, i)
	}
	return out
}

func Hash[T emulated.FieldParams](field *emulated.Field[T], inputs []*emulated.Element[T]) *emulated.Element[T] {
	out := HashEx(field, inputs, field.NewElement(0), 1)
	return out[0]
}

func HashMulti[T emulated.FieldParams](field *emulated.Field[T], inputs []*emulated.Element[T]) *emulated.Element[T] {
	groups := (len(inputs) + 15) / 16
	state := []*emulated.Element[T]{field.NewElement(0)}
	for i := 0; i < groups-1; i++ {
		state = HashEx(field, inputs[i*16:(i+1)*16], state[0], 1)
	}
	state = HashEx(field, inputs[(groups-1)*16:], state[0], 1)
	return state[0]
}
